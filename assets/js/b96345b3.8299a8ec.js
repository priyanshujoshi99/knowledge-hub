"use strict";(self.webpackChunkprep_up=self.webpackChunkprep_up||[]).push([[4465],{3371:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>t});const i=JSON.parse('{"id":"JavaScript/Advance/LexicalScopingClosure","title":"Lexical Scoping and Closures in JavaScript","description":"Overview","source":"@site/docs/JavaScript/09_Advance/LexicalScopingClosure.md","sourceDirName":"JavaScript/09_Advance","slug":"/JavaScript/Advance/LexicalScopingClosure","permalink":"/knowledge-hub/docs/JavaScript/Advance/LexicalScopingClosure","draft":false,"unlisted":false,"editUrl":"https://priyanshujoshi99.github.io/knowledge-hub/docs/JavaScript/09_Advance/LexicalScopingClosure.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"JavaScript Async Code Execution","permalink":"/knowledge-hub/docs/JavaScript/Events/asyncCodeExecution"},"next":{"title":"Promises in JavaScript","permalink":"/knowledge-hub/docs/JavaScript/Advance/PromisesAndFetch"}}');var c=s(4848),r=s(8453);const l={},o="Lexical Scoping and Closures in JavaScript",a={},t=[{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"1. <strong>Lexical Scoping</strong>",id:"1-lexical-scoping",level:3},{value:"2. <strong>Closures</strong>",id:"2-closures",level:3},{value:"Code Snippet Breakdown",id:"code-snippet-breakdown",level:2},{value:"1. <strong>Basic Example of Lexical Scoping</strong>",id:"1-basic-example-of-lexical-scoping",level:3},{value:"2. <strong>Nested Functions and Scope Chain</strong>",id:"2-nested-functions-and-scope-chain",level:3},{value:"3. <strong>Closure Example</strong>",id:"3-closure-example",level:3},{value:"4. <strong>Practical Use of Closures (Event Handlers)</strong>",id:"4-practical-use-of-closures-event-handlers",level:3},{value:"Additional Points",id:"additional-points",level:2},{value:"1. <strong>Advantages of Closures</strong>",id:"1-advantages-of-closures",level:3},{value:"2. <strong>Common Pitfalls</strong>",id:"2-common-pitfalls",level:3},{value:"3. <strong>Lexical Scoping vs Dynamic Scoping</strong>",id:"3-lexical-scoping-vs-dynamic-scoping",level:3},{value:"Interesting Facts",id:"interesting-facts",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"lexical-scoping-and-closures-in-javascript",children:"Lexical Scoping and Closures in JavaScript"})}),"\n",(0,c.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Lexical Scoping"})," and ",(0,c.jsx)(n.strong,{children:"Closures"})," are fundamental concepts in JavaScript that govern how variables are accessed and functions retain access to their lexical environment even after the outer function has finished executing."]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,c.jsxs)(n.h3,{id:"1-lexical-scoping",children:["1. ",(0,c.jsx)(n.strong,{children:"Lexical Scoping"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Lexical scoping means that the scope of a variable is determined by its position in the source code."}),"\n",(0,c.jsx)(n.li,{children:"Inner functions have access to variables declared in their outer (enclosing) functions."}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"2-closures",children:["2. ",(0,c.jsx)(n.strong,{children:"Closures"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"A closure is a function that retains access to its lexical scope, even when the function is executed outside that scope."}),"\n",(0,c.jsx)(n.li,{children:"Closures are created every time a function is created, at function creation time."}),"\n"]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"code-snippet-breakdown",children:"Code Snippet Breakdown"}),"\n",(0,c.jsxs)(n.h3,{id:"1-basic-example-of-lexical-scoping",children:["1. ",(0,c.jsx)(n.strong,{children:"Basic Example of Lexical Scoping"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"function init() {\n  let name = 'Mozilla';\n  function displayName() {\n    console.log(name);\n  }\n  displayName();\n}\ninit();\n"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Explanation"}),":","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"displayName"})," is an inner function that has access to the ",(0,c.jsx)(n.code,{children:"name"})," variable from its outer function ",(0,c.jsx)(n.code,{children:"init"}),"."]}),"\n",(0,c.jsx)(n.li,{children:"This demonstrates lexical scoping, where the inner function can access variables from its outer scope."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsxs)(n.h3,{id:"2-nested-functions-and-scope-chain",children:["2. ",(0,c.jsx)(n.strong,{children:"Nested Functions and Scope Chain"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"function outer() {\n  let username = 'john';\n  console.log('OUTER', secret); // Error: secret is not defined\n  function inner() {\n    let secret = 'my123';\n    console.log('inner', username); // \"john\"\n  }\n  function innerTwo() {\n    console.log('innerTwo', username); // \"john\"\n    console.log(secret); // Error: secret is not defined\n  }\n  inner();\n  innerTwo();\n}\nouter();\nconsole.log('TOO OUTER', username); // Error: username is not defined\n"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Explanation"}),":","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"inner"})," and ",(0,c.jsx)(n.code,{children:"innerTwo"})," are nested functions inside ",(0,c.jsx)(n.code,{children:"outer"}),"."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"inner"})," can access ",(0,c.jsx)(n.code,{children:"username"})," from ",(0,c.jsx)(n.code,{children:"outer"})," but cannot access ",(0,c.jsx)(n.code,{children:"secret"})," from ",(0,c.jsx)(n.code,{children:"innerTwo"})," because of block scoping."]}),"\n",(0,c.jsx)(n.li,{children:"Variables declared in an outer scope are accessible to inner functions, but not vice versa."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsxs)(n.h3,{id:"3-closure-example",children:["3. ",(0,c.jsx)(n.strong,{children:"Closure Example"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"function makeFunc() {\n  const name = 'Mozilla';\n  function displayName() {\n    console.log(name);\n  }\n  return displayName;\n}\n\nconst myFunc = makeFunc();\nmyFunc(); // \"Mozilla\"\n"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Explanation"}),":","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"makeFunc"})," returns the ",(0,c.jsx)(n.code,{children:"displayName"})," function, which retains access to the ",(0,c.jsx)(n.code,{children:"name"})," variable even after ",(0,c.jsx)(n.code,{children:"makeFunc"})," has finished executing."]}),"\n",(0,c.jsxs)(n.li,{children:["This is a closure, where the inner function (",(0,c.jsx)(n.code,{children:"displayName"}),') "closes over" the ',(0,c.jsx)(n.code,{children:"name"})," variable."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsxs)(n.h3,{id:"4-practical-use-of-closures-event-handlers",children:["4. ",(0,c.jsx)(n.strong,{children:"Practical Use of Closures (Event Handlers)"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"function clickHandler(color) {\n  return function () {\n    document.body.style.backgroundColor = `${color}`;\n  };\n}\n\ndocument.getElementById('orange').onclick = clickHandler('orange');\ndocument.getElementById('green').onclick = clickHandler('green');\n"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Explanation"}),":","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"clickHandler"})," returns a function that changes the background color of the document body."]}),"\n",(0,c.jsxs)(n.li,{children:["The returned function forms a closure over the ",(0,c.jsx)(n.code,{children:"color"})," parameter, allowing it to remember the ",(0,c.jsx)(n.code,{children:"color"})," value even after ",(0,c.jsx)(n.code,{children:"clickHandler"})," has finished executing."]}),"\n",(0,c.jsx)(n.li,{children:"This is a practical use of closures in event handling."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"additional-points",children:"Additional Points"}),"\n",(0,c.jsxs)(n.h3,{id:"1-advantages-of-closures",children:["1. ",(0,c.jsx)(n.strong,{children:"Advantages of Closures"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Data Encapsulation"}),": Closures allow you to create private variables and methods."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Function Factories"}),": Closures can be used to create functions with preset parameters."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Callbacks and Event Handlers"}),": Closures are widely used in asynchronous programming, such as in event listeners and callbacks."]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"2-common-pitfalls",children:["2. ",(0,c.jsx)(n.strong,{children:"Common Pitfalls"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Memory Leaks"}),": Closures can cause memory leaks if not used carefully, as they retain references to their outer scope."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Performance Overhead"}),": Excessive use of closures can lead to performance issues due to increased memory consumption."]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"3-lexical-scoping-vs-dynamic-scoping",children:["3. ",(0,c.jsx)(n.strong,{children:"Lexical Scoping vs Dynamic Scoping"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Lexical Scoping"}),": Scope is determined at the time of writing the code (compile time)."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Dynamic Scoping"}),": Scope is determined at runtime (not used in JavaScript)."]}),"\n"]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"interesting-facts",children:"Interesting Facts"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Closures are a powerful feature of JavaScript and are used extensively in libraries like React (e.g., hooks) and frameworks like Angular."}),"\n",(0,c.jsx)(n.li,{children:"Closures are often used in functional programming to create higher-order functions."}),"\n",(0,c.jsx)(n.li,{children:"The concept of closures is not unique to JavaScript; it exists in other languages like Python, Ruby, and Swift."}),"\n"]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Lexical Scoping"}),": Determines the accessibility of variables based on their position in the code."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Closures"}),": Functions that retain access to their lexical scope, even when executed outside that scope."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Practical Use"}),": Closures are widely used in event handling, callbacks, and data encapsulation."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var i=s(6540);const c={},r=i.createContext(c);function l(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);