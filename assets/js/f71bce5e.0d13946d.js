"use strict";(self.webpackChunkprep_up=self.webpackChunkprep_up||[]).push([[3937],{4259:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>u,frontMatter:()=>c,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"DSA/Basics/BasicRecursion","title":"Basic Recursion","description":"1. Sum of First N Numbers","source":"@site/docs/DSA/2. Basics/BasicRecursion.md","sourceDirName":"DSA/2. Basics","slug":"/DSA/Basics/BasicRecursion","permalink":"/knowledge-hub/docs/DSA/Basics/BasicRecursion","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/DSA/2. Basics/BasicRecursion.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Basic Math","permalink":"/knowledge-hub/docs/DSA/Basics/BasicMath"},"next":{"title":"Basic Strings","permalink":"/knowledge-hub/docs/DSA/Basics/BasicStrings"}}');var r=s(4848),l=s(8453);const c={},t="Basic Recursion",a={},o=[{value:"1. Sum of First N Numbers",id:"1-sum-of-first-n-numbers",level:2},{value:"2. Factorial of a Given Number",id:"2-factorial-of-a-given-number",level:2},{value:"3. Sum of Array Elements",id:"3-sum-of-array-elements",level:2},{value:"4. Reverse a String",id:"4-reverse-a-string",level:2},{value:"5. Check if String is Palindrome",id:"5-check-if-string-is-palindrome",level:2},{value:"6. Check if a Number is Prime",id:"6-check-if-a-number-is-prime",level:2},{value:"7. Reverse an Array",id:"7-reverse-an-array",level:2},{value:"8. Check if the Array is Sorted",id:"8-check-if-the-array-is-sorted",level:2},{value:"9. Sum of Digits in a Given Number",id:"9-sum-of-digits-in-a-given-number",level:2},{value:"10. Fibonacci Number",id:"10-fibonacci-number",level:2},{value:"General Notes on Recursion:",id:"general-notes-on-recursion",level:3}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"basic-recursion",children:"Basic Recursion"})}),"\n",(0,r.jsx)(n.h2,{id:"1-sum-of-first-n-numbers",children:"1. Sum of First N Numbers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Solution {\n    public int NnumbersSum(int N) {\n        if(N == 0) return 0; // Base case\n        return N + NnumbersSum(N-1); // Recursive case\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The function makes N recursive calls, each reducing the problem size by 1."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The recursion stack will have a depth of N."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Base case is crucial to avoid infinite recursion."}),"\n",(0,r.jsx)(n.li,{children:"Tail recursion can be optimized by some compilers."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-factorial-of-a-given-number",children:"2. Factorial of a Given Number"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Solution {\n    public long factorial(int n) {\n        if(n == 0) return 1; // Base case\n        return n * factorial(n-1); // Recursive case\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The function makes N recursive calls."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The recursion stack will have a depth of N."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Factorial grows very quickly, so use ",(0,r.jsx)(n.code,{children:"long"})," to avoid overflow."]}),"\n",(0,r.jsxs)(n.li,{children:["Base case for ",(0,r.jsx)(n.code,{children:"n == 0"})," is essential."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-sum-of-array-elements",children:"3. Sum of Array Elements"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Solution {\n    public int sum(int n, int[] nums) {\n        if(n < 0) return 0; // Base case\n        return nums[n] + sum(n-1, nums); // Recursive case\n    }\n    public int arraySum(int[] nums) {\n        int n = nums.length - 1;\n        return sum(n, nums);\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The function processes each element once."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The recursion stack will have a depth of N."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The helper function ",(0,r.jsx)(n.code,{children:"sum"})," is used to handle the recursion."]}),"\n",(0,r.jsx)(n.li,{children:"Base case ensures the recursion stops when all elements are processed."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"4-reverse-a-string",children:"4. Reverse a String"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Solution {\n    private void reverse(Vector<Character> s, int left, int right) {\n        if(left >= right) return; // Base case\n\n        char temp = s.get(left);\n        s.set(left, s.get(right));\n        s.set(right, temp);\n\n        reverse(s, left+1, right-1); // Recursive case\n    }\n    public Vector<Character> reverseString(Vector<Character> s) {\n        int left = 0;\n        int right = s.size() - 1;\n        reverse(s, left, right);\n        return s;\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The function swaps N/2 elements."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The recursion stack will have a depth of N/2."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The base case ensures the recursion stops when the pointers meet or cross."}),"\n",(0,r.jsxs)(n.li,{children:["Using two pointers (",(0,r.jsx)(n.code,{children:"left"})," and ",(0,r.jsx)(n.code,{children:"right"}),") is a common technique for reversing."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"5-check-if-string-is-palindrome",children:"5. Check if String is Palindrome"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Solution {\n    private boolean isPalindrome(String s, int left, int right) {\n        if(left >= right) return true; // Base case\n\n        if(s.charAt(left) != s.charAt(right)) return false;\n\n        return isPalindrome(s, left+1, right-1); // Recursive case\n    }\n    public boolean palindromeCheck(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n        return isPalindrome(s, left, right);\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The function checks each character pair once."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The recursion stack will have a depth of N/2."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The base case ensures the recursion stops when the pointers meet or cross."}),"\n",(0,r.jsxs)(n.li,{children:["The function returns ",(0,r.jsx)(n.code,{children:"false"})," as soon as a mismatch is found."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"6-check-if-a-number-is-prime",children:"6. Check if a Number is Prime"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Solution {\n    private boolean isPrime(int num, int x) {\n        if(x > Math.sqrt(num)) return true; // Base case\n\n        if(num % x == 0) return false;\n\n        return isPrime(num, x+1); // Recursive case\n    }\n    public boolean checkPrime(int num) {\n        if(num <= 1) return false;\n        return isPrime(num, 2);\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(\u221aN)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The function checks divisibility up to the square root of ",(0,r.jsx)(n.code,{children:"num"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(\u221aN)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The recursion stack will have a depth of \u221aN."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The base case checks divisibility up to the square root of ",(0,r.jsx)(n.code,{children:"num"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Numbers less than or equal to 1 are not prime."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"7-reverse-an-array",children:"7. Reverse an Array"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Solution {\n    private void reverse(int[] nums, int left, int right) {\n        if (left >= right) return; // Base case\n\n        int temp = nums[left];\n        nums[left] = nums[right];\n        nums[right] = temp;\n\n        reverse(nums, left + 1, right - 1); // Recursive case\n    }\n    public int[] reverseArray(int[] nums) {\n        int left = 0;\n        int right = nums.length - 1;\n        reverse(nums, left, right);\n        return nums;\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The function swaps N/2 elements."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The recursion stack will have a depth of N/2."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The base case ensures the recursion stops when the pointers meet or cross."}),"\n",(0,r.jsxs)(n.li,{children:["Using two pointers (",(0,r.jsx)(n.code,{children:"left"})," and ",(0,r.jsx)(n.code,{children:"right"}),") is a common technique for reversing."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"8-check-if-the-array-is-sorted",children:"8. Check if the Array is Sorted"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Solution {\n    private boolean checkSorted(ArrayList<Integer> nums, int left, int right) {\n        if (right >= nums.size()) return true; // Base case\n\n        if (nums.get(left) > nums.get(right)) return false;\n\n        return checkSorted(nums, left + 1, right + 1); // Recursive case\n    }\n    public boolean isSorted(ArrayList<Integer> nums) {\n        if (nums.size() <= 1) return true;\n        return checkSorted(nums, 0, 1);\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The function checks each pair of elements once."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The recursion stack will have a depth of N."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The base case ensures the recursion stops when all elements are checked."}),"\n",(0,r.jsxs)(n.li,{children:["The function returns ",(0,r.jsx)(n.code,{children:"false"})," as soon as an unsorted pair is found."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"9-sum-of-digits-in-a-given-number",children:"9. Sum of Digits in a Given Number"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Solution {\n    public int addDigits(int num) {\n        if(num < 10) return num; // Base case\n\n        int sum = 0;\n        while(num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        return addDigits(sum); // Recursive case\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(log N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The function processes each digit of the number."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(log N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The recursion stack will have a depth proportional to the number of digits."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The base case ensures the recursion stops when the number is a single digit."}),"\n",(0,r.jsx)(n.li,{children:"The function reduces the number to a single digit by summing its digits."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"10-fibonacci-number",children:"10. Fibonacci Number"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Solution {\n    public int fib(int n) {\n        if(n==0) return 0; // Base case\n        if(n==1) return 1; // Base case\n\n        return fib(n-1) + fib(n-2); // Recursive case\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(2^N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The function makes two recursive calls for each Fibonacci number."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The recursion stack will have a depth of N."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Important Notes"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The base cases for ",(0,r.jsx)(n.code,{children:"n == 0"})," and ",(0,r.jsx)(n.code,{children:"n == 1"})," are essential."]}),"\n",(0,r.jsx)(n.li,{children:"This approach is inefficient due to repeated calculations; consider using memoization or dynamic programming for optimization."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"general-notes-on-recursion",children:"General Notes on Recursion:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Base Case"}),": Always define a base case to stop the recursion."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recursive Case"}),": Ensure the problem size reduces with each recursive call."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": Often depends on the number of recursive calls."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": Depends on the depth of the recursion stack."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimization"}),": Tail recursion and memoization can optimize recursive solutions."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>t});var i=s(6540);const r={},l=i.createContext(r);function c(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);