"use strict";(self.webpackChunkprep_up=self.webpackChunkprep_up||[]).push([[1880],{1209:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"DSA/Sorting/Sorting","title":"Sorting Algorithms","description":"Selection Sort","source":"@site/docs/DSA/3. Sorting/Sorting.md","sourceDirName":"DSA/3. Sorting","slug":"/DSA/Sorting/Sorting","permalink":"/knowledge-hub/docs/DSA/Sorting/Sorting","draft":false,"unlisted":false,"editUrl":"https://priyanshujoshi99.github.io/knowledge-hub/docs/DSA/3. Sorting/Sorting.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Basic Strings","permalink":"/knowledge-hub/docs/DSA/Basics/BasicStrings"},"next":{"title":"Left Rotate Array by K Places","permalink":"/knowledge-hub/docs/DSA/Arrays/Fundamentals/LeftRotateArrayByKPlaces"}}');var r=i(4848),s=i(8453);const l={},o="Sorting Algorithms",a={},h=[{value:"Selection Sort",id:"selection-sort",level:2},{value:"Intuition",id:"intuition",level:3},{value:"Approach",id:"approach",level:3},{value:"Algorithm",id:"algorithm",level:3},{value:"Time &amp; Space Complexity",id:"time--space-complexity",level:3},{value:"Bubble Sort",id:"bubble-sort",level:2},{value:"Intuition",id:"intuition-1",level:3},{value:"Approach",id:"approach-1",level:3},{value:"Algorithm",id:"algorithm-1",level:3},{value:"Time &amp; Space Complexity",id:"time--space-complexity-1",level:3},{value:"Insertion Sort",id:"insertion-sort",level:2},{value:"Intuition",id:"intuition-2",level:3},{value:"Approach",id:"approach-2",level:3},{value:"Algorithm",id:"algorithm-2",level:3},{value:"Time &amp; Space Complexity",id:"time--space-complexity-2",level:3},{value:"Merge Sort",id:"merge-sort",level:2},{value:"Intuition",id:"intuition-3",level:3},{value:"Approach",id:"approach-3",level:3},{value:"Algorithm",id:"algorithm-3",level:3},{value:"Time &amp; Space Complexity",id:"time--space-complexity-3",level:3},{value:"Quick Sort",id:"quick-sort",level:2},{value:"Intuition",id:"intuition-4",level:3},{value:"Approach",id:"approach-4",level:3},{value:"Algorithm",id:"algorithm-4",level:3},{value:"Time &amp; Space Complexity",id:"time--space-complexity-4",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"sorting-algorithms",children:"Sorting Algorithms"})}),"\n",(0,r.jsx)(n.h2,{id:"selection-sort",children:"Selection Sort"}),"\n",(0,r.jsx)(n.h3,{id:"intuition",children:"Intuition"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The selection sort algorithm sorts an array by repeatedly finding the minimum element from the unsorted part and putting it at the beginning."}),"\n",(0,r.jsx)(n.li,{children:"The largest element will end up at the last index of the array."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"approach",children:"Approach"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Select the starting index of the unsorted part using a loop with i from 0 to n-1."}),"\n",(0,r.jsx)(n.li,{children:"Find the smallest element in the range from i to n-1 using an inner loop."}),"\n",(0,r.jsx)(n.li,{children:"Swap this smallest element with the element at index i."}),"\n",(0,r.jsx)(n.li,{children:"Repeat the process for the next starting index."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"algorithm",children:"Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Solution {\n  public int[] selectionSort(int[] nums) {\n    for (int i = 0; i < nums.length - 1; i++) {\n      int min = i;\n      for (int j = i + 1; j < nums.length; j++) {\n        if (nums[j] < nums[min]) min = j;\n      }\n      int temp = nums[i];\n      nums[i] = nums[min];\n      nums[min] = temp;\n    }\n\n    return nums;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"time--space-complexity",children:"Time & Space Complexity"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Time Complexity: O(N",(0,r.jsx)("sup",{children:"2"}),")"]})," where N is the length of the input array. The outer loop runs through each element, and the inner loop finds the smallest element in the unsorted portion of the array."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity: O(1)"})," as it is an in-place sorting algorithm and does not require additional storage proportional to the input size."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"bubble-sort",children:"Bubble Sort"}),"\n",(0,r.jsx)(n.h3,{id:"intuition-1",children:"Intuition"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The bubble sort algorithm sorts an array by repeatedly swapping adjacent elements if they are in the wrong order."}),"\n",(0,r.jsx)(n.li,{children:'The largest elements "bubble" to the end of the array with each pass.'}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"approach-1",children:"Approach"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Run a loop i from n-1 to 0."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Run a inner loop from j from 0 to i-1."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"If arr[j] > arr[j+1], swap them."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Continue until the array is sorted."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," Here, after each iteration, the array becomes sorted up to the last index of the range. That is why the last index of the range decreases by 1 after each iteration. This decrement is managed by the outer loop, where the last index is represented by the variable i. The inner loop (variable j) helps to push the maximum element of the range [0...i] to the last index (i.e., index i)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"algorithm-1",children:"Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Solution {\n  public int[] bubbleSort(int[] nums) {\n    int n = nums.length;\n\n    for (int i = n - 1; i >= 0; i--) {\n      boolean isSwapped = false;\n\n      for (int j = 0; j <= i - 1; j++) {\n        if (nums[j] > nums[j + 1]) {\n          int temp = nums[j];\n          nums[j] = nums[j + 1];\n          nums[j + 1] = temp;\n          isSwapped = true;\n        }\n      }\n\n      if (!isSwapped) break;\n    }\n\n    return nums;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"time--space-complexity-1",children:"Time & Space Complexity"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Time Complexity: O(N",(0,r.jsx)("sup",{children:"2"}),")"]})," for the worst and average cases and O(N) for the best case. Here, N is the size of the array."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity: O(1)"}),", because Bubble Sort is an in-place sorting algorithm, meaning it only requires a constant amount of extra space for its operations, regardless of the size of the input array."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"insertion-sort",children:"Insertion Sort"}),"\n",(0,r.jsx)(n.h3,{id:"intuition-2",children:"Intuition"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Insertion sort builds a sorted array one element at a time by repeatedly picking the next element and inserting it into its correct position within the already sorted part of the array."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"approach-2",children:"Approach"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"In each iteration, select an element from the unsorted part of the array using an outer loop."}),"\n",(0,r.jsx)(n.li,{children:"Place this element in its correct position within the sorted part of the array."}),"\n",(0,r.jsx)(n.li,{children:"Use an inner loop to shift the remaining elements as necessary to accommodate the selected element. This involves swapping elements until the selected element is in its correct position."}),"\n",(0,r.jsx)(n.li,{children:"Continue this process until the entire array is sorted."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"algorithm-2",children:"Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public int[] insertionSort(int[] nums) {\n    int n = nums.length;\n    // Traverse through the array\n    for (int i = 1; i < n; i++) {\n        int key = nums[i];\n        int j = i - 1;\n\n        // Swap elements till we reach greater element\n        while (j >= 0 && nums[j] > key) {\n            nums[j + 1] = nums[j];\n            j = j - 1;\n        }\n        nums[j + 1] = key;\n    }\n    return nums;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"time--space-complexity-2",children:"Time & Space Complexity"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Time Complexity: O(N",(0,r.jsx)("sup",{children:"2"}),")"]})," for the worst and average cases, where N is the size of the array. This is because the outer loop runs N times, and for each pass, the inner loop runs up to N times as well, resulting in approximately N x N operations, hence O(N2). The best-case time complexity occurs when the array is already sorted, in which case the inner loop doesn't run at all, leading to a time complexity of O(N)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity: O(1)"})," because Insertion Sort is an in-place sorting algorithm, meaning it sorts the array by modifying the original array without using additional data structures that grow with the size of the input."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"merge-sort",children:"Merge Sort"}),"\n",(0,r.jsx)(n.h3,{id:"intuition-3",children:"Intuition"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Merge Sort is a powerful sorting algorithm that follows the divide-and-conquer approach. The array is divided into two equal halves until each sub-array contains only one element. Each pair of smaller sorted arrays is then merged into a larger sorted array."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The algorithm consists of two main functions:"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"merge():"})," This function merges the two halves of the array, assuming both parts are already sorted."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"mergeSort():"})," This function divides the array into 2 parts: low to mid and mid+1 to high where, low is the leftmost index of the array, high is the rightmost index of the array, and mid is the middle index of the array."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"By repeating these steps recursively, Merge Sort efficiently sorts the entire array."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"approach-3",children:"Approach"}),"\n",(0,r.jsx)(n.p,{children:"To implement Merge Sort, we will create two functions: mergeSort() and merge()."}),"\n",(0,r.jsx)(n.p,{children:"mergeSort(arr[], low, high)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Divide the Array:"})," Split the given array into two halves by splitting the range. For any range from low to high, the splits will be low to mid and mid+1 to high, where mid = (low + high) / 2. This process continues until the range size is 1."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recursive Division:"})," In mergeSort(), divide the array around the middle index by making recursive calls: mergeSort(arr, low, mid) for the left half and mergeSort(arr, mid+1, high) for the right half. Here, low is the leftmost index, high is the rightmost index, and mid is the middle index of the array."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Base Case:"})," To complete the recursive function, define the base case. The recursion ends when the array has only one element left, meaning low and high are the same, pointing to a single element. If low >= high, the function returns."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"merge(arr[], low, mid, high)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use a temporary array to store the elements of the two sorted halves after merging. The range of the left half is from low to mid and the range of the right half is from mid+1 to high."}),"\n",(0,r.jsxs)(n.li,{children:["Use two pointers, left starting from low and right starting from mid+1. Using a while loop (while left ",(0,r.jsx)(n.code,{children:"<="})," mid && right ",(0,r.jsx)(n.code,{children:"<="})," high), compare the elements from each half and insert the smaller one into the temporary array. After the loop, any leftover elements in both halves are copied into the temporary array."]}),"\n",(0,r.jsx)(n.li,{children:"Transfer the elements from the temporary array back to the original array in the range low to high."}),"\n",(0,r.jsx)(n.li,{children:"This approach ensures that the array is efficiently sorted using the divide-and-conquer strategy of Merge Sort."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"algorithm-3",children:"Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"import java.util.*;\n\nclass Solution {\n  public void merge(int[] nums, int low, int mid, int high) {\n    List<Integer> li = new ArrayList<>();\n    int left = low;\n    int right = mid + 1;\n\n    while (left <= mid && right <= high) {\n      if (nums[left] <= nums[right]) {\n        li.add(nums[left]);\n        left++;\n      } else {\n        li.add(nums[right]);\n        right++;\n      }\n    }\n\n    while (left <= mid) {\n      li.add(nums[left]);\n      left++;\n    }\n\n    while (right <= high) {\n      li.add(nums[right]);\n      right++;\n    }\n\n    // Copy back to original array\n    for (int i = 0; i < li.size(); i++) {\n      nums[low + i] = li.get(i); // Copy back to correct position\n    }\n  }\n\n  public void mergeSortHelper(int[] nums, int low, int high) {\n    if (low >= high) return;\n\n    int mid = (low + high) / 2;\n\n    mergeSortHelper(nums, low, mid);\n    mergeSortHelper(nums, mid + 1, high);\n\n    merge(nums, low, mid, high);\n  }\n\n  public int[] mergeSort(int[] nums) {\n    mergeSortHelper(nums, 0, nums.length - 1);\n    return nums;\n  }\n}\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"time--space-complexity-3",children:"Time & Space Complexity"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity: O(nlogn)"}),". At each step, we divide the whole array, which takes logn steps, and we assume n steps are taken to sort the array. So, the overall time complexity is nlogn."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity: O(n)"}),". We are using a temporary array to store elements in sorted order."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"quick-sort",children:"Quick Sort"}),"\n",(0,r.jsx)(n.h3,{id:"intuition-4",children:"Intuition"}),"\n",(0,r.jsx)(n.p,{children:"Quick Sort is a divide-and-conquer algorithm like Merge Sort. However, unlike Merge Sort, Quick Sort does not use an extra array for sorting (though it uses an auxiliary stack space). This makes Quick Sort slightly better than Merge Sort from a space perspective."}),"\n",(0,r.jsx)(n.p,{children:"This algorithm follows two simple steps repeatedly:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pick a pivot and place it in its correct position in the sorted array."}),"\n",(0,r.jsx)(n.li,{children:"Move smaller elements (i.e., smaller than the pivot) to the left of the pivot and larger ones to the right."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"To summarize:"})," The main goal is to place the pivot at its final position in each recursion call, where it should be in the final sorted array."]}),"\n",(0,r.jsx)(n.h3,{id:"approach-4",children:"Approach"}),"\n",(0,r.jsx)(n.p,{children:"To implement Quick Sort, we will create two functions: quickSort() and partition()."}),"\n",(0,r.jsx)(n.p,{children:"quickSort(arr[], low, high)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Initial Setup:"})," The low pointer points to the first index, and the high pointer points to the last index of the array."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Partitioning:"})," Use the partition() function to get the index where the pivot should be placed after sorting. This index, called the partition index, separates the left and right unsorted subarrays."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recursive Calls:"})," After placing the pivot at the partition index, recursively call quickSort() for the left and right subarrays. The range of the left subarray will be [low to partition index - 1] and the range of the right subarray will be [partition index + 1 to high]."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Base Case:"})," The recursion continues until the range becomes 1."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"partition(arr[], low, high)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Select pivot (e.g., arr[low])."}),"\n",(0,r.jsxs)(n.li,{children:["Use pointers i (low) and j (high). Move i forward to find element > pivot, and j backward to find element < pivot. Ensure i ",(0,r.jsx)(n.code,{children:"<="})," high - 1 and j ",(0,r.jsx)(n.code,{children:">="})," low + 1."]}),"\n",(0,r.jsx)(n.li,{children:"If i < j, swap arr[i] and arr[j]."}),"\n",(0,r.jsx)(n.li,{children:"Continue until j < i."}),"\n",(0,r.jsx)(n.li,{children:"Swap pivot (arr[low]) with arr[j] and return j as partition index."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This approach ensures that Quick Sort efficiently sorts the array using the divide-and-conquer strategy."}),"\n",(0,r.jsx)(n.h3,{id:"algorithm-4",children:"Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Solution {\n  public int findPivotIndex(int[] nums, int low, int high) {\n    int pivot = nums[low];\n    int i = low;\n    int j = high;\n\n    while (i < j) {\n      while (i <= high - 1 && nums[i] <= pivot) i++;\n      while (j >= low + 1 && nums[j] >= pivot) j--;\n\n      if (i < j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n      }\n    }\n\n    int temp = nums[low];\n    nums[low] = nums[j];\n    nums[j] = temp;\n\n    return j;\n  }\n\n  public void quickSortHelper(int[] nums, int low, int high) {\n    if (low >= high) return;\n\n    int pivotIndex = findPivotIndex(nums, low, high);\n\n    quickSortHelper(nums, low, pivotIndex - 1);\n    quickSortHelper(nums, pivotIndex + 1, high);\n  }\n\n  public int[] quickSort(int[] nums) {\n    quickSortHelper(nums, 0, nums.length - 1);\n    return nums;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"time--space-complexity-4",children:"Time & Space Complexity"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity: O(nlogn)"}),", where N = size of the array. At each step, we divide the whole array, which takes logN steps, and n steps are taken for the partition() function, so overall time complexity will be N*logN.\nThe following recurrence relation can be written for Quick sort:"]}),"\n",(0,r.jsx)(n.p,{children:"F(n) = F(k) + F(n-1-k)"}),"\n",(0,r.jsx)(n.p,{children:"Here, k is the number of elements smaller or equal to the pivot and n-1-k denotes elements greater than the pivot."}),"\n",(0,r.jsx)(n.p,{children:"There can be 2 cases:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Worst Case:"})," This case occurs when the pivot is the greatest or smallest element of the array. If the partition is done and the last element is the pivot, then the worst case would be either in the increasing order of the array or in the decreasing order of the array."]}),"\n",(0,r.jsx)(n.p,{children:"Recurrence:"}),"\n",(0,r.jsx)(n.p,{children:"F(n) = F(0) + F(n-1) or F(n) = F(n-1) + F(0)"}),"\n",(0,r.jsx)(n.p,{children:"Worst Case Time Complexity: O(n2)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Best Case:"})," This case occurs when the pivot is the middle element or near to middle element of the array."]}),"\n",(0,r.jsx)(n.p,{children:"Recurrence:"}),"\n",(0,r.jsx)(n.p,{children:"F(n) = 2F(n/2)"}),"\n",(0,r.jsx)(n.p,{children:"Time Complexity for the best and average case: O(N*logN)"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity: O(1) + O(N) auxiliary stack space"}),", where N = size of the array."]}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var t=i(6540);const r={},s=t.createContext(r);function l(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);